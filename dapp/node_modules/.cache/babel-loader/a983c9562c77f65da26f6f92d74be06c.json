{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nimport { is, check, remove, MATCH, internalErr, SAGA_ACTION } from './utils';\nimport { buffers } from './buffers';\nimport { asap } from './scheduler';\nvar CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';\nexport var END = {\n  type: CHANNEL_END_TYPE\n};\nexport var isEnd = function isEnd(a) {\n  return a && a.type === CHANNEL_END_TYPE;\n};\nexport function emitter() {\n  var subscribers = [];\n  function subscribe(sub) {\n    subscribers.push(sub);\n    return function () {\n      return remove(subscribers, sub);\n    };\n  }\n  function emit(item) {\n    var arr = subscribers.slice();\n    for (var i = 0, len = arr.length; i < len; i++) {\n      arr[i](item);\n    }\n  }\n  return {\n    subscribe: subscribe,\n    emit: emit\n  };\n}\nexport var INVALID_BUFFER = 'invalid buffer passed to channel factory function';\nexport var UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';\nif (process.env.NODE_ENV !== 'production') {\n  UNDEFINED_INPUT_ERROR += '\\nHints:\\n    - check that your Action Creator returns a non-undefined value\\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\\n  ';\n}\nexport function channel() {\n  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : buffers.fixed();\n  var closed = false;\n  var takers = [];\n  check(buffer, is.buffer, INVALID_BUFFER);\n  function checkForbiddenStates() {\n    if (closed && takers.length) {\n      throw internalErr('Cannot have a closed channel with pending takers');\n    }\n    if (takers.length && !buffer.isEmpty()) {\n      throw internalErr('Cannot have pending takers with non empty buffer');\n    }\n  }\n  function put(input) {\n    checkForbiddenStates();\n    check(input, is.notUndef, UNDEFINED_INPUT_ERROR);\n    if (closed) {\n      return;\n    }\n    if (!takers.length) {\n      return buffer.put(input);\n    }\n    for (var i = 0; i < takers.length; i++) {\n      var cb = takers[i];\n      if (!cb[MATCH] || cb[MATCH](input)) {\n        takers.splice(i, 1);\n        return cb(input);\n      }\n    }\n  }\n  function take(cb) {\n    checkForbiddenStates();\n    check(cb, is.func, \"channel.take's callback must be a function\");\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n    } else if (!buffer.isEmpty()) {\n      cb(buffer.take());\n    } else {\n      takers.push(cb);\n      cb.cancel = function () {\n        return remove(takers, cb);\n      };\n    }\n  }\n  function flush(cb) {\n    checkForbiddenStates(); // TODO: check if some new state should be forbidden now\n    check(cb, is.func, \"channel.flush' callback must be a function\");\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n      return;\n    }\n    cb(buffer.flush());\n  }\n  function close() {\n    checkForbiddenStates();\n    if (!closed) {\n      closed = true;\n      if (takers.length) {\n        var arr = takers;\n        takers = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n          arr[i](END);\n        }\n      }\n    }\n  }\n  return {\n    take: take,\n    put: put,\n    flush: flush,\n    close: close,\n    get __takers__() {\n      return takers;\n    },\n    get __closed__() {\n      return closed;\n    }\n  };\n}\nexport function eventChannel(subscribe) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : buffers.none();\n  var matcher = arguments[2];\n\n  /**\n    should be if(typeof matcher !== undefined) instead?\n    see PR #273 for a background discussion\n  **/\n  if (arguments.length > 2) {\n    check(matcher, is.func, 'Invalid match function passed to eventChannel');\n  }\n  var chan = channel(buffer);\n  var close = function close() {\n    if (!chan.__closed__) {\n      if (unsubscribe) {\n        unsubscribe();\n      }\n      chan.close();\n    }\n  };\n  var unsubscribe = subscribe(function (input) {\n    if (isEnd(input)) {\n      close();\n      return;\n    }\n    if (matcher && !matcher(input)) {\n      return;\n    }\n    chan.put(input);\n  });\n  if (chan.__closed__) {\n    unsubscribe();\n  }\n  if (!is.func(unsubscribe)) {\n    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');\n  }\n  return {\n    take: chan.take,\n    flush: chan.flush,\n    close: close\n  };\n}\nexport function stdChannel(subscribe) {\n  var chan = eventChannel(function (cb) {\n    return subscribe(function (input) {\n      if (input[SAGA_ACTION]) {\n        cb(input);\n        return;\n      }\n      asap(function () {\n        return cb(input);\n      });\n    });\n  });\n  return _extends({}, chan, {\n    take: function take(cb, matcher) {\n      if (arguments.length > 1) {\n        check(matcher, is.func, \"channel.take's matcher argument must be a function\");\n        cb[MATCH] = matcher;\n      }\n      chan.take(cb);\n    }\n  });\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","is","check","remove","MATCH","internalErr","SAGA_ACTION","buffers","asap","CHANNEL_END_TYPE","END","type","isEnd","a","emitter","subscribers","subscribe","sub","push","emit","item","arr","slice","len","INVALID_BUFFER","UNDEFINED_INPUT_ERROR","process","env","NODE_ENV","channel","buffer","undefined","fixed","closed","takers","checkForbiddenStates","isEmpty","put","input","notUndef","cb","splice","take","func","cancel","flush","close","__takers__","__closed__","eventChannel","none","matcher","chan","unsubscribe","Error","stdChannel"],"sources":["/home/pablo/Desktop/DAO/dapp/node_modules/redux-saga/es/internal/channel.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport { is, check, remove, MATCH, internalErr, SAGA_ACTION } from './utils';\nimport { buffers } from './buffers';\nimport { asap } from './scheduler';\n\nvar CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';\nexport var END = { type: CHANNEL_END_TYPE };\nexport var isEnd = function isEnd(a) {\n  return a && a.type === CHANNEL_END_TYPE;\n};\n\nexport function emitter() {\n  var subscribers = [];\n\n  function subscribe(sub) {\n    subscribers.push(sub);\n    return function () {\n      return remove(subscribers, sub);\n    };\n  }\n\n  function emit(item) {\n    var arr = subscribers.slice();\n    for (var i = 0, len = arr.length; i < len; i++) {\n      arr[i](item);\n    }\n  }\n\n  return {\n    subscribe: subscribe,\n    emit: emit\n  };\n}\n\nexport var INVALID_BUFFER = 'invalid buffer passed to channel factory function';\nexport var UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';\n\nif (process.env.NODE_ENV !== 'production') {\n  UNDEFINED_INPUT_ERROR += '\\nHints:\\n    - check that your Action Creator returns a non-undefined value\\n    - if the Saga was started using runSaga, check that your subscribe source provides the action to its listeners\\n  ';\n}\n\nexport function channel() {\n  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : buffers.fixed();\n\n  var closed = false;\n  var takers = [];\n\n  check(buffer, is.buffer, INVALID_BUFFER);\n\n  function checkForbiddenStates() {\n    if (closed && takers.length) {\n      throw internalErr('Cannot have a closed channel with pending takers');\n    }\n    if (takers.length && !buffer.isEmpty()) {\n      throw internalErr('Cannot have pending takers with non empty buffer');\n    }\n  }\n\n  function put(input) {\n    checkForbiddenStates();\n    check(input, is.notUndef, UNDEFINED_INPUT_ERROR);\n    if (closed) {\n      return;\n    }\n    if (!takers.length) {\n      return buffer.put(input);\n    }\n    for (var i = 0; i < takers.length; i++) {\n      var cb = takers[i];\n      if (!cb[MATCH] || cb[MATCH](input)) {\n        takers.splice(i, 1);\n        return cb(input);\n      }\n    }\n  }\n\n  function take(cb) {\n    checkForbiddenStates();\n    check(cb, is.func, \"channel.take's callback must be a function\");\n\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n    } else if (!buffer.isEmpty()) {\n      cb(buffer.take());\n    } else {\n      takers.push(cb);\n      cb.cancel = function () {\n        return remove(takers, cb);\n      };\n    }\n  }\n\n  function flush(cb) {\n    checkForbiddenStates(); // TODO: check if some new state should be forbidden now\n    check(cb, is.func, \"channel.flush' callback must be a function\");\n    if (closed && buffer.isEmpty()) {\n      cb(END);\n      return;\n    }\n    cb(buffer.flush());\n  }\n\n  function close() {\n    checkForbiddenStates();\n    if (!closed) {\n      closed = true;\n      if (takers.length) {\n        var arr = takers;\n        takers = [];\n        for (var i = 0, len = arr.length; i < len; i++) {\n          arr[i](END);\n        }\n      }\n    }\n  }\n\n  return {\n    take: take,\n    put: put,\n    flush: flush,\n    close: close,\n    get __takers__() {\n      return takers;\n    },\n    get __closed__() {\n      return closed;\n    }\n  };\n}\n\nexport function eventChannel(subscribe) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : buffers.none();\n  var matcher = arguments[2];\n\n  /**\n    should be if(typeof matcher !== undefined) instead?\n    see PR #273 for a background discussion\n  **/\n  if (arguments.length > 2) {\n    check(matcher, is.func, 'Invalid match function passed to eventChannel');\n  }\n\n  var chan = channel(buffer);\n  var close = function close() {\n    if (!chan.__closed__) {\n      if (unsubscribe) {\n        unsubscribe();\n      }\n      chan.close();\n    }\n  };\n  var unsubscribe = subscribe(function (input) {\n    if (isEnd(input)) {\n      close();\n      return;\n    }\n    if (matcher && !matcher(input)) {\n      return;\n    }\n    chan.put(input);\n  });\n  if (chan.__closed__) {\n    unsubscribe();\n  }\n\n  if (!is.func(unsubscribe)) {\n    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');\n  }\n\n  return {\n    take: chan.take,\n    flush: chan.flush,\n    close: close\n  };\n}\n\nexport function stdChannel(subscribe) {\n  var chan = eventChannel(function (cb) {\n    return subscribe(function (input) {\n      if (input[SAGA_ACTION]) {\n        cb(input);\n        return;\n      }\n      asap(function () {\n        return cb(input);\n      });\n    });\n  });\n\n  return _extends({}, chan, {\n    take: function take(cb, matcher) {\n      if (arguments.length > 1) {\n        check(matcher, is.func, \"channel.take's matcher argument must be a function\");\n        cb[MATCH] = matcher;\n      }\n      chan.take(cb);\n    }\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}