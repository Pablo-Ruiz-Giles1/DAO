{"ast":null,"code":"var queue = [];\n/**\n  Variable to hold a counting semaphore\n  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not\n    already suspended)\n  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This\n    triggers flushing the queued tasks.\n**/\nvar semaphore = 0;\n\n/**\n  Executes a task 'atomically'. Tasks scheduled during this execution will be queued\n  and flushed after this task has finished (assuming the scheduler endup in a released\n  state).\n**/\nfunction exec(task) {\n  try {\n    suspend();\n    task();\n  } finally {\n    release();\n  }\n}\n\n/**\n  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)\n**/\nexport function asap(task) {\n  queue.push(task);\n  if (!semaphore) {\n    suspend();\n    flush();\n  }\n}\n\n/**\n  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the\n  scheduler is released.\n**/\nexport function suspend() {\n  semaphore++;\n}\n\n/**\n  Puts the scheduler in a `released` state.\n**/\nfunction release() {\n  semaphore--;\n}\n\n/**\n  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.\n**/\nexport function flush() {\n  release();\n  var task = void 0;\n  while (!semaphore && (task = queue.shift()) !== undefined) {\n    exec(task);\n  }\n}","map":{"version":3,"names":["queue","semaphore","exec","task","suspend","release","asap","push","flush","shift","undefined"],"sources":["/home/pablo/Desktop/DAO/dapp/node_modules/redux-saga/es/internal/scheduler.js"],"sourcesContent":["var queue = [];\n/**\n  Variable to hold a counting semaphore\n  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not\n    already suspended)\n  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This\n    triggers flushing the queued tasks.\n**/\nvar semaphore = 0;\n\n/**\n  Executes a task 'atomically'. Tasks scheduled during this execution will be queued\n  and flushed after this task has finished (assuming the scheduler endup in a released\n  state).\n**/\nfunction exec(task) {\n  try {\n    suspend();\n    task();\n  } finally {\n    release();\n  }\n}\n\n/**\n  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)\n**/\nexport function asap(task) {\n  queue.push(task);\n\n  if (!semaphore) {\n    suspend();\n    flush();\n  }\n}\n\n/**\n  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the\n  scheduler is released.\n**/\nexport function suspend() {\n  semaphore++;\n}\n\n/**\n  Puts the scheduler in a `released` state.\n**/\nfunction release() {\n  semaphore--;\n}\n\n/**\n  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.\n**/\nexport function flush() {\n  release();\n\n  var task = void 0;\n  while (!semaphore && (task = queue.shift()) !== undefined) {\n    exec(task);\n  }\n}"],"mappings":"AAAA,IAAIA,KAAK,GAAG,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,SAAS,GAAG,CAAC;;AAEjB;AACA;AACA;AACA;AACA;AACA,SAASC,IAAIA,CAACC,IAAI,EAAE;EAClB,IAAI;IACFC,OAAO,CAAC,CAAC;IACTD,IAAI,CAAC,CAAC;EACR,CAAC,SAAS;IACRE,OAAO,CAAC,CAAC;EACX;AACF;;AAEA;AACA;AACA;AACA,OAAO,SAASC,IAAIA,CAACH,IAAI,EAAE;EACzBH,KAAK,CAACO,IAAI,CAACJ,IAAI,CAAC;EAEhB,IAAI,CAACF,SAAS,EAAE;IACdG,OAAO,CAAC,CAAC;IACTI,KAAK,CAAC,CAAC;EACT;AACF;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASJ,OAAOA,CAAA,EAAG;EACxBH,SAAS,EAAE;AACb;;AAEA;AACA;AACA;AACA,SAASI,OAAOA,CAAA,EAAG;EACjBJ,SAAS,EAAE;AACb;;AAEA;AACA;AACA;AACA,OAAO,SAASO,KAAKA,CAAA,EAAG;EACtBH,OAAO,CAAC,CAAC;EAET,IAAIF,IAAI,GAAG,KAAK,CAAC;EACjB,OAAO,CAACF,SAAS,IAAI,CAACE,IAAI,GAAGH,KAAK,CAACS,KAAK,CAAC,CAAC,MAAMC,SAAS,EAAE;IACzDR,IAAI,CAACC,IAAI,CAAC;EACZ;AACF"},"metadata":{},"sourceType":"module"}